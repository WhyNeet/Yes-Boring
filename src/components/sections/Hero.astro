---
import CircleArrowDown from "lucide-astro/CircleArrowDown";
---

<section
  class="h-screen w-screen flex items-center justify-end flex-col pb-10 relative overflow-hidden"
>
  <canvas class="absolute inset-0 h-screen w-screen -z-10 max-[925px]:-translate-y-44" id="intro-canvas"
  ></canvas>
  <h1
    class="text-7xl min-[420px]:text-8xl md:text-9xl font-bold uppercase mb-10 bg-gradient-to-t from-black to-neutral-600 bg-clip-text text-transparent text-center mx-10"
  >
    Yes, boring
  </h1>
  <div
    class="bg-white/20 backdrop-blur-xs rounded-full px-2 py-2 border border-neutral-200"
  >
    <div class="animate-pulse flex items-center gap-2 text-neutral-400 text-sm">
      <CircleArrowDown class="h-6 w-6 stroke-[1.5]" />
      Keep scrolling, I won't judge.
    </div>
  </div>
  <div
    class="scene absolute inset-y-0 -inset-x-full -z-20 perspective-midrange"
  >
    <div class="floor-grid absolute inset-0 bottom-0"></div>
  </div>
  <div class="absolute gradient -inset-x-20 -bottom-4 h-8 blur-3xl -z-10"></div>
</section>

<style is:global>
  .gradient {
    background-image: linear-gradient(
      to right,
      oklch(85.2% 0.199 91.936),
      oklch(63.7% 0.237 25.331),
      oklch(68.5% 0.169 237.323),
      oklch(76.5% 0.177 163.223)
    );
  }
</style>

<style>
  .floor-grid {
    background-size:
      40px 40px,
      40px 40px;
    background-image:
      linear-gradient(to right, var(--color-neutral-200) 1px, transparent 1px),
      linear-gradient(to bottom, var(--color-neutral-200) 1px, transparent 1px);
    animation: grid-move linear infinite 10000ms;
    transform: rotateX(90deg);
    transform-origin: bottom center;
    mask-image: linear-gradient(to top, black 0%, transparent 100%);
  }
</style>

<script>
  const scale = 2;
  const canvas = document.getElementById("intro-canvas")! as HTMLCanvasElement;
  const cx = canvas.getContext("2d")!;

  window.addEventListener("resize", resize);

  function resize() {
    const { height, width } = canvas.getBoundingClientRect();
    canvas.height = height * scale;
    canvas.width = width * scale;
  }

  let time = 0;

  resize();

  let refreshCanvas = false;


  const update = () => {
    if (!refreshCanvas) return;

    cx.clearRect(0, 0, canvas.width * scale, canvas.height * scale);

    cx.fillStyle = "black";

    for (let x = 0; x < canvas.width / scale / 40; x++) {
      const y = Math.sin(x + time) * 40 + canvas.height / scale / 2;
      cx.beginPath();
      cx.arc(
        x * scale * 40 + 20 * scale,
        y * scale,
        13 * scale,
        0,
        Math.PI * 2,
      );
      cx.fill();
    }

    time += 0.05;

    requestAnimationFrame(update);
  };

  const handleScroll = () => {
    if (window.scrollY > window.innerHeight) {
      refreshCanvas = false;
    } else if (!refreshCanvas) {
      refreshCanvas = true;
      update();
    }
  };
  handleScroll();
  window.addEventListener("scroll", handleScroll);
</script>
